---
# Automates Keycloak SSO configuration:
# - Imports realm JSON (idempotent)
# - Configures LDAP federation against FreeIPA (idempotent)
# - Exports OIDC client secrets to Kubernetes secrets (optional)

- name: Check whether SSO automation is enabled
  assert:
    that:
      - keycloak_configure_sso | default(true) | bool
    quiet: true
  changed_when: false

- name: Validate required variables are present
  assert:
    that:
      - infra_node is defined
      - namespace_identity is defined
      - keycloak_admin_password_effective is defined
      - (keycloak_admin_password_effective | trim) != ''
      - freeipa_admin_password is defined
      - (freeipa_admin_password | trim) != ''
    fail_msg: >-
      Missing required inputs for SSO automation.
      Ensure Keycloak is deployed (admin secret read-back ran) and FreeIPA admin password is available.
  changed_when: false

- name: Render cluster realm configuration (authoritative)
  template:
    src: cluster-realm.json.j2
    dest: "{{ keycloak_realm_json_path }}"
    owner: root
    group: root
    mode: '0600'
  become: true

- name: Resolve infra node InternalIP for Keycloak NodePort access
  shell: >-
    KUBECONFIG=/etc/kubernetes/admin.conf kubectl get node {{ infra_node }}
    -o jsonpath='{.status.addresses[?(@.type=="InternalIP")].address}'
  register: infra_node_ip
  changed_when: false
  become: true

- name: Set Keycloak admin base URL
  set_fact:
    keycloak_admin_base_url: "http://{{ infra_node_ip.stdout | trim }}:{{ keycloak_nodeport_http }}{{ keycloak_base_path }}"

- name: Request Keycloak admin access token (with retry)
  include_tasks: refresh-token.yml

- name: Check if realm already exists (retry once on 401)
  block:
    - name: Check if realm already exists (attempt 1)
      uri:
        url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}"
        method: GET
        headers:
          Authorization: "Bearer {{ keycloak_bearer_token }}"
        status_code:
          - 200
          - 404
          - 401
        timeout: 60
      register: keycloak_realm_check_attempt

    - name: Refresh token if unauthorized
      include_tasks: refresh-token.yml
      when: keycloak_realm_check_attempt.status == 401

    - name: Check if realm already exists (attempt 2)
      uri:
        url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}"
        method: GET
        headers:
          Authorization: "Bearer {{ keycloak_bearer_token }}"
        status_code:
          - 200
          - 404
        timeout: 60
      register: keycloak_realm_check
      when: keycloak_realm_check_attempt.status == 401

    - name: Set realm check result (no retry needed)
      set_fact:
        keycloak_realm_check: "{{ keycloak_realm_check_attempt }}"
      when: keycloak_realm_check_attempt.status != 401

- name: Import realm from JSON when missing
  block:
    - name: Import realm from JSON when missing (attempt 1)
      uri:
        url: "{{ keycloak_admin_base_url }}/admin/realms"
        method: POST
        headers:
          Authorization: "Bearer {{ keycloak_bearer_token }}"
          Content-Type: application/json
        body_format: json
        body: "{{ lookup('file', keycloak_realm_json_path) | from_json }}"
        return_content: true
        status_code:
          - 201
          - 409
          - 401
        timeout: 120
      register: keycloak_realm_import_attempt

    - name: Refresh token if unauthorized
      include_tasks: refresh-token.yml
      when: keycloak_realm_import_attempt.status == 401

    - name: Import realm from JSON when missing (attempt 2)
      uri:
        url: "{{ keycloak_admin_base_url }}/admin/realms"
        method: POST
        headers:
          Authorization: "Bearer {{ keycloak_bearer_token }}"
          Content-Type: application/json
        body_format: json
        body: "{{ lookup('file', keycloak_realm_json_path) | from_json }}"
        return_content: true
        status_code:
          - 201
          - 409
        timeout: 120
      register: keycloak_realm_import
      when: keycloak_realm_import_attempt.status == 401

    - name: Set realm import result (no retry needed)
      set_fact:
        keycloak_realm_import: "{{ keycloak_realm_import_attempt }}"
      when: keycloak_realm_import_attempt.status != 401
  when: keycloak_realm_check.status == 404

- name: Fetch realm details (to obtain realm UUID) (attempt 1)
  uri:
    url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}"
    method: GET
    headers:
      Authorization: "Bearer {{ keycloak_bearer_token }}"
    status_code:
      - 200
      - 401
    timeout: 60
  register: keycloak_realm_details_attempt

- name: Refresh token if unauthorized
  include_tasks: refresh-token.yml
  when: keycloak_realm_details_attempt.status == 401

- name: Fetch realm details (to obtain realm UUID) (attempt 2, wait for readiness)
  uri:
    url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}"
    method: GET
    headers:
      Authorization: "Bearer {{ keycloak_bearer_token }}"
    status_code: 200
    timeout: 60
  register: keycloak_realm_details
  retries: 10
  delay: 3
  until: keycloak_realm_details.json is defined and (keycloak_realm_details.json.id | default('') | trim) != ''
  when: keycloak_realm_details_attempt.status == 401

- name: Set realm details result (no retry needed)
  set_fact:
    keycloak_realm_details: "{{ keycloak_realm_details_attempt }}"
  when: keycloak_realm_details_attempt.status != 401

- name: Set Keycloak realm UUID fact
  set_fact:
    keycloak_realm_id: "{{ keycloak_realm_details.json.id }}"

- name: Verify FreeIPA LDAP service is reachable from inside the cluster (TCP)
  block:
    - name: "Preflight: show CoreDNS and service/endpoints status (diagnostic)"
      shell: >-
        set -eu;
        export KUBECONFIG=/etc/kubernetes/admin.conf;
        echo '--- CoreDNS (kube-system) ---';
        kubectl -n kube-system get deploy coredns 2>/dev/null || true;
        kubectl -n kube-system get pods -l k8s-app=kube-dns -o wide 2>/dev/null || true;
        kubectl -n kube-system get svc kube-dns 2>/dev/null || true;
        echo '--- FreeIPA Service/Endpoints ({{ namespace_identity }}) ---';
        kubectl -n {{ namespace_identity }} get svc freeipa -o wide 2>/dev/null || true;
        kubectl -n {{ namespace_identity }} get endpoints freeipa -o wide 2>/dev/null || true;
        kubectl -n {{ namespace_identity }} get pod freeipa-0 -o wide 2>/dev/null || true
      become: true
      changed_when: false
      failed_when: false

    - name: "Preflight: ensure FreeIPA Service has endpoints (fail fast)"
      shell: >-
        KUBECONFIG=/etc/kubernetes/admin.conf kubectl -n {{ namespace_identity }}
        get endpoints freeipa -o jsonpath='{.subsets[*].addresses[*].ip}'
      become: true
      register: freeipa_endpoints_ips
      changed_when: false

    - name: Fail if FreeIPA Service has no endpoints
      fail:
        msg: |
          Service freeipa in namespace {{ namespace_identity }} has no endpoints.
          FreeIPA pod likely isn't Ready or the Service selector doesn't match.

          Quick checks:
          - kubectl -n {{ namespace_identity }} get pod freeipa-0 -o wide
          - kubectl -n {{ namespace_identity }} describe svc freeipa
          - kubectl -n {{ namespace_identity }} get endpoints freeipa -o wide
      when: (freeipa_endpoints_ips.stdout | default('') | trim) == ''

    - name: Delete previous ldap-port-check job (if any)
      shell: >-
        KUBECONFIG=/etc/kubernetes/admin.conf kubectl -n {{ namespace_identity }}
        delete job ldap-port-check --ignore-not-found
      become: true
      changed_when: false

    - name: Create ldap-port-check job
      shell: >-
        KUBECONFIG=/etc/kubernetes/admin.conf kubectl -n {{ namespace_identity }}
        create job ldap-port-check --image=busybox:1.36 --
        sh -c 'set -eu;
        echo "Checking freeipa LDAP ports";
        echo "--- /etc/resolv.conf ---"; cat /etc/resolv.conf || true; echo "-----------------------";
        cluster_host="kubernetes.default.svc.cluster.local";
        cluster_ip="$(nslookup "$cluster_host" 2>/dev/null | awk "/^Address: /{print \$2; exit}" || true)";
        if [ -z "${cluster_ip}" ]; then
          echo "DNS lookup failed for ${cluster_host}";
          exit 3;
        fi;
        echo "Resolved ${cluster_host} -> ${cluster_ip}";
        host="freeipa.{{ namespace_identity }}.svc.cluster.local";
        ip="$(nslookup "$host" 2>/dev/null | awk "/^Address: /{print \$2; exit}" || true)";
        if [ -z "${ip}" ]; then
          echo "DNS lookup failed for ${host}";
          exit 2;
        fi;
        echo "Resolved ${host} -> ${ip}";
        nc -z -w 5 "${ip}" 389;
        nc -z -w 5 "${ip}" 636;
        echo "OK"'
      become: true
      changed_when: true

    - name: Wait for ldap-port-check job to finish (succeeded or failed)
      shell: >-
        KUBECONFIG=/etc/kubernetes/admin.conf kubectl -n {{ namespace_identity }}
        get job ldap-port-check -o jsonpath='{.status.succeeded} {.status.failed}'
      become: true
      register: ldap_port_check_status
      retries: 60
      delay: 2
      until: >-
        ((((ldap_port_check_status.stdout | default('')) ~ ' ').split(' ')[0] | default('0') | int) > 0)
        or ((((ldap_port_check_status.stdout | default('')) ~ ' ').split(' ')[1] | default('0') | int) > 0)
      changed_when: false

    - name: Parse ldap-port-check job result counts
      set_fact:
        ldap_port_check_succeeded: "{{ (((ldap_port_check_status.stdout | default('')) ~ ' ').split(' ')[0] | default('0')) | int }}"
        ldap_port_check_failed: "{{ (((ldap_port_check_status.stdout | default('')) ~ ' ').split(' ')[1] | default('0')) | int }}"

    - name: Fetch ldap-port-check job logs
      shell: >-
        KUBECONFIG=/etc/kubernetes/admin.conf kubectl -n {{ namespace_identity }}
        logs job/ldap-port-check
      become: true
      register: ldap_port_check_logs
      changed_when: false

    - name: Delete ldap-port-check job
      shell: >-
        KUBECONFIG=/etc/kubernetes/admin.conf kubectl -n {{ namespace_identity }}
        delete job ldap-port-check --ignore-not-found
      become: true
      changed_when: false

    - name: Fail if ldap-port-check job indicates failure (DNS or port reachability)
      fail:
        msg: |
          FreeIPA LDAP service is not reachable from within the cluster.

          Expected service DNS: freeipa.{{ namespace_identity }}.svc.cluster.local
          Expected ports: 389 (LDAP), 636 (LDAPS)

          Diagnosis:
          {% set logs = (ldap_port_check_logs.stdout | default('')) %}
          {% if 'DNS lookup failed for kubernetes.default.svc.cluster.local' in logs %}
          - Cluster DNS is failing (kubernetes.default did not resolve). Verify CoreDNS/kube-dns is running and reachable.
          {% elif ('DNS lookup failed for freeipa.' ~ namespace_identity ~ '.svc.cluster.local') in logs or 'bad address' in logs %}
          - Cluster DNS works, but Service DNS for FreeIPA failed. Verify the Service "freeipa" exists in namespace "{{ namespace_identity }}".
          {% else %}
          - DNS resolved but TCP connect failed. Verify FreeIPA pod is Running/Ready and the Service selector matches the FreeIPA pod labels.
          {% endif %}

          Job logs:
          {{ logs }}
    when: (ldap_port_check_failed | default(0) | int) > 0
  rescue:
    - name: Fetch ldap-port-check job logs (best-effort)
      shell: >-
        KUBECONFIG=/etc/kubernetes/admin.conf kubectl -n {{ namespace_identity }}
        logs job/ldap-port-check || true
      become: true
      register: ldap_port_check_logs
      changed_when: false

    - name: Delete ldap-port-check job (best-effort)
      shell: >-
        KUBECONFIG=/etc/kubernetes/admin.conf kubectl -n {{ namespace_identity }}
        delete job ldap-port-check --ignore-not-found || true
      become: true
      changed_when: false

    - name: Fail with actionable LDAP reachability error
      fail:
        msg: |
          FreeIPA LDAP service is not reachable from within the cluster.

          Expected service DNS: freeipa.{{ namespace_identity }}.svc.cluster.local
          Expected ports: 389 (LDAP), 636 (LDAPS)

          Job logs:
          {{ (ldap_port_check_logs.stdout | default('')) if ldap_port_check_logs is defined else '' }}

- name: Fetch existing LDAP user federation providers (attempt 1)
  uri:
    url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/components?type=org.keycloak.storage.UserStorageProvider"
    method: GET
    headers:
      Authorization: "Bearer {{ keycloak_bearer_token }}"
    status_code:
      - 200
      - 401
    timeout: 60
  register: keycloak_user_storage_components_attempt

- name: Refresh token if unauthorized
  include_tasks: refresh-token.yml
  when: keycloak_user_storage_components_attempt.status == 401

- name: Fetch existing LDAP user federation providers (attempt 2)
  uri:
    url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/components?type=org.keycloak.storage.UserStorageProvider"
    method: GET
    headers:
      Authorization: "Bearer {{ keycloak_bearer_token }}"
    status_code: 200
    timeout: 60
  register: keycloak_user_storage_components
  when: keycloak_user_storage_components_attempt.status == 401

- name: Set LDAP provider list result (no retry needed)
  set_fact:
    keycloak_user_storage_components: "{{ keycloak_user_storage_components_attempt }}"
  when: keycloak_user_storage_components_attempt.status != 401

- name: Collect all existing FreeIPA LDAP provider components
  set_fact:
    keycloak_freeipa_components: >-
      {{ (keycloak_user_storage_components.json | default([]))
         | selectattr('providerId', 'equalto', 'ldap')
         | selectattr('name', 'equalto', 'freeipa')
         | list }}

- name: Compute FreeIPA LDAP component cleanup plan
  set_fact:
    keycloak_freeipa_components_good: >-
      {{ (keycloak_freeipa_components | default([]))
         | selectattr('parentId', 'equalto', keycloak_realm_id)
         | list }}
    keycloak_freeipa_components_bad: >-
      {{ (keycloak_freeipa_components | default([]))
         | rejectattr('parentId', 'equalto', keycloak_realm_id)
         | list }}

- name: Delete incorrect FreeIPA LDAP components (wrong parentId)
  block:
    - name: Delete incorrect FreeIPA LDAP components (attempt 1)
      uri:
        url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/components/{{ item.id }}"
        method: DELETE
        headers:
          Authorization: "Bearer {{ keycloak_bearer_token }}"
        status_code:
          - 204
          - 404
          - 401
        timeout: 60
      loop: "{{ keycloak_freeipa_components_bad | default([]) }}"
      register: keycloak_delete_bad_components_attempt
      when: (keycloak_freeipa_components_bad | default([]) | length) > 0

    - name: Detect unauthorized deletes (bad components)
      set_fact:
        keycloak_delete_bad_components_unauthorized: >-
          {{ (keycloak_delete_bad_components_attempt.results | default([]))
             | selectattr('status', 'equalto', 401)
             | list
             | length > 0 }}
      when: keycloak_delete_bad_components_attempt is defined

    - name: Refresh token if any delete returned 401 (bad components)
      include_tasks: refresh-token.yml
      when: keycloak_delete_bad_components_unauthorized | default(false) | bool

    - name: Retry deletes that returned 401 (bad components)
      uri:
        url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/components/{{ item.id }}"
        method: DELETE
        headers:
          Authorization: "Bearer {{ keycloak_bearer_token }}"
        status_code:
          - 204
          - 404
        timeout: 60
      loop: >-
        {{ (keycloak_delete_bad_components_attempt.results | default([]))
           | selectattr('status', 'equalto', 401)
           | map(attribute='item')
           | list }}
      when: keycloak_delete_bad_components_unauthorized | default(false) | bool

- name: Delete duplicate FreeIPA LDAP components (keep one)
  block:
    - name: Delete duplicate FreeIPA LDAP components (attempt 1)
      uri:
        url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/components/{{ item.id }}"
        method: DELETE
        headers:
          Authorization: "Bearer {{ keycloak_bearer_token }}"
        status_code:
          - 204
          - 404
          - 401
        timeout: 60
      loop: "{{ (keycloak_freeipa_components_good | default([]))[1:] }}"
      register: keycloak_delete_duplicate_components_attempt
      when: (keycloak_freeipa_components_good | default([]) | length) > 1

    - name: Detect unauthorized deletes (duplicate components)
      set_fact:
        keycloak_delete_duplicate_components_unauthorized: >-
          {{ (keycloak_delete_duplicate_components_attempt.results | default([]))
             | selectattr('status', 'equalto', 401)
             | list
             | length > 0 }}
      when: keycloak_delete_duplicate_components_attempt is defined

    - name: Refresh token if any delete returned 401 (duplicate components)
      include_tasks: refresh-token.yml
      when: keycloak_delete_duplicate_components_unauthorized | default(false) | bool

    - name: Retry deletes that returned 401 (duplicate components)
      uri:
        url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/components/{{ item.id }}"
        method: DELETE
        headers:
          Authorization: "Bearer {{ keycloak_bearer_token }}"
        status_code:
          - 204
          - 404
        timeout: 60
      loop: >-
        {{ (keycloak_delete_duplicate_components_attempt.results | default([]))
           | selectattr('status', 'equalto', 401)
           | map(attribute='item')
           | list }}
      when: keycloak_delete_duplicate_components_unauthorized | default(false) | bool

- name: Refresh LDAP user federation providers after cleanup (attempt 1)
  uri:
    url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/components?type=org.keycloak.storage.UserStorageProvider"
    method: GET
    headers:
      Authorization: "Bearer {{ keycloak_bearer_token }}"
    status_code:
      - 200
      - 401
    timeout: 60
  register: keycloak_user_storage_components_clean_attempt

- name: Refresh token if unauthorized
  include_tasks: refresh-token.yml
  when: keycloak_user_storage_components_clean_attempt.status == 401

- name: Refresh LDAP user federation providers after cleanup (attempt 2)
  uri:
    url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/components?type=org.keycloak.storage.UserStorageProvider"
    method: GET
    headers:
      Authorization: "Bearer {{ keycloak_bearer_token }}"
    status_code: 200
    timeout: 60
  register: keycloak_user_storage_components_clean
  when: keycloak_user_storage_components_clean_attempt.status == 401

- name: Set LDAP provider list (post-cleanup) result (no retry needed)
  set_fact:
    keycloak_user_storage_components_clean: "{{ keycloak_user_storage_components_clean_attempt }}"
  when: keycloak_user_storage_components_clean_attempt.status != 401

- name: Select existing FreeIPA LDAP provider component (post-cleanup)
  set_fact:
    keycloak_freeipa_component: >-
      {{ (keycloak_user_storage_components_clean.json | default([]))
         | selectattr('providerId', 'equalto', 'ldap')
         | selectattr('name', 'equalto', 'freeipa')
         | selectattr('parentId', 'equalto', keycloak_realm_id)
         | list
         | first
         | default({}) }}

- name: Build desired FreeIPA LDAP federation component payload
  set_fact:
    keycloak_freeipa_component_payload:
      name: "freeipa"
      providerId: "ldap"
      providerType: "org.keycloak.storage.UserStorageProvider"
      parentId: "{{ keycloak_realm_id }}"
      config:
        enabled: ["true"]
        vendor: ["rhds"]
        editMode: ["READ_ONLY"]
        importEnabled: ["true"]
        connectionUrl: ["{{ freeipa_ldap_connection_url }}"]
        usersDn: ["{{ freeipa_ldap_users_dn }}"]
        bindDn: ["{{ freeipa_ldap_bind_dn }}"]
        bindCredential: ["{{ freeipa_admin_password }}"]
        authType: ["simple"]
        usernameLDAPAttribute: ["uid"]
        rdnLDAPAttribute: ["uid"]
        uuidLDAPAttribute: ["nsuniqueid"]
        userObjectClasses: ["inetOrgPerson,organizationalPerson"]
        searchScope: ["1"]
        pagination: ["true"]
        batchSizeForSync: ["1000"]
        connectionPooling: ["true"]
        connectionTimeout: ["5000"]
        readTimeout: ["60000"]

- name: Create FreeIPA LDAP federation provider when missing
  block:
    - name: Create FreeIPA LDAP federation provider when missing (attempt 1)
      uri:
        url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/components"
        method: POST
        headers:
          Authorization: "Bearer {{ keycloak_bearer_token }}"
          Content-Type: application/json
        body_format: json
        body: "{{ keycloak_freeipa_component_payload }}"
        status_code:
          - 201
          - 409
          - 401
        timeout: 60
      register: keycloak_create_freeipa_component_attempt

    - name: Refresh token if unauthorized
      include_tasks: refresh-token.yml
      when: keycloak_create_freeipa_component_attempt.status == 401

    - name: Create FreeIPA LDAP federation provider when missing (attempt 2)
      uri:
        url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/components"
        method: POST
        headers:
          Authorization: "Bearer {{ keycloak_bearer_token }}"
          Content-Type: application/json
        body_format: json
        body: "{{ keycloak_freeipa_component_payload }}"
        status_code:
          - 201
          - 409
        timeout: 60
      when: keycloak_create_freeipa_component_attempt.status == 401
  when: keycloak_freeipa_component == {}

- name: Update FreeIPA LDAP federation provider when present
  block:
    - name: Update FreeIPA LDAP federation provider when present (attempt 1)
      uri:
        url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/components/{{ keycloak_freeipa_component.id }}"
        method: PUT
        headers:
          Authorization: "Bearer {{ keycloak_bearer_token }}"
          Content-Type: application/json
        body_format: json
        body: "{{ keycloak_freeipa_component_payload | combine({'id': keycloak_freeipa_component.id}, recursive=true) }}"
        status_code:
          - 204
          - 401
        timeout: 60
      register: keycloak_update_freeipa_component_attempt

    - name: Refresh token if unauthorized
      include_tasks: refresh-token.yml
      when: keycloak_update_freeipa_component_attempt.status == 401

    - name: Update FreeIPA LDAP federation provider when present (attempt 2)
      uri:
        url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/components/{{ keycloak_freeipa_component.id }}"
        method: PUT
        headers:
          Authorization: "Bearer {{ keycloak_bearer_token }}"
          Content-Type: application/json
        body_format: json
        body: "{{ keycloak_freeipa_component_payload | combine({'id': keycloak_freeipa_component.id}, recursive=true) }}"
        status_code: 204
        timeout: 60
      when: keycloak_update_freeipa_component_attempt.status == 401
  when: keycloak_freeipa_component != {}

- name: Refresh LDAP component id (after create/update) (attempt 1)
  uri:
    url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/components?type=org.keycloak.storage.UserStorageProvider"
    method: GET
    headers:
      Authorization: "Bearer {{ keycloak_bearer_token }}"
    status_code:
      - 200
      - 401
    timeout: 60
  register: keycloak_user_storage_components_after_attempt

- name: Refresh token if unauthorized
  include_tasks: refresh-token.yml
  when: keycloak_user_storage_components_after_attempt.status == 401

- name: Refresh LDAP component id (after create/update) (attempt 2)
  uri:
    url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/components?type=org.keycloak.storage.UserStorageProvider"
    method: GET
    headers:
      Authorization: "Bearer {{ keycloak_bearer_token }}"
    status_code: 200
    timeout: 60
  register: keycloak_user_storage_components_after
  when: keycloak_user_storage_components_after_attempt.status == 401

- name: Set LDAP provider list (post create/update) result (no retry needed)
  set_fact:
    keycloak_user_storage_components_after: "{{ keycloak_user_storage_components_after_attempt }}"
  when: keycloak_user_storage_components_after_attempt.status != 401

- name: Set FreeIPA LDAP component id fact
  set_fact:
    keycloak_freeipa_component_id: >-
      {{ (keycloak_user_storage_components_after.json | default([]))
         | selectattr('providerId', 'equalto', 'ldap')
         | selectattr('name', 'equalto', 'freeipa')
         | map(attribute='id')
         | list
         | first
         | default('') }}

- name: Trigger full LDAP sync (best-effort)
  uri:
    url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/user-storage/{{ keycloak_freeipa_component_id }}/sync?action=triggerFullSync"
    method: POST
    headers:
      Authorization: "Bearer {{ keycloak_bearer_token }}"
    status_code:
      - 200
      - 204
      - 400
      - 404
    timeout: 120
  when: (keycloak_freeipa_component_id | trim) != ''
  failed_when: false

- name: Export OIDC client secrets to Kubernetes (optional)
  when: keycloak_export_oidc_client_secrets | default(true) | bool
  block:
    - name: Ensure monitoring namespace exists
      shell: >-
        KUBECONFIG=/etc/kubernetes/admin.conf kubectl create namespace {{ namespace_monitoring }}
        --dry-run=client -o yaml | kubectl apply -f -
      become: true
      changed_when: false

    - name: Resolve client UUIDs for OIDC clients
      uri:
        url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/clients?clientId={{ item.client_id }}"
        method: GET
        headers:
          Authorization: "Bearer {{ keycloak_bearer_token }}"
        status_code:
          - 200
          - 401
        timeout: 60
      loop: "{{ keycloak_oidc_clients }}"
      register: keycloak_client_lookup

    - name: Detect unauthorized responses during client UUID lookup
      set_fact:
        keycloak_client_lookup_unauthorized: >-
          {{ (keycloak_client_lookup.results | default([]))
             | selectattr('status', 'equalto', 401)
             | list
             | length > 0 }}

    - name: Refresh token if any client UUID lookup returned 401
      include_tasks: refresh-token.yml
      when: keycloak_client_lookup_unauthorized | bool

    - name: Retry resolving client UUIDs after token refresh
      uri:
        url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/clients?clientId={{ item.client_id }}"
        method: GET
        headers:
          Authorization: "Bearer {{ keycloak_bearer_token }}"
        status_code: 200
        timeout: 60
      loop: "{{ keycloak_oidc_clients }}"
      when: keycloak_client_lookup_unauthorized | bool
      register: keycloak_client_lookup_retry

    - name: Select effective client UUID lookup results
      set_fact:
        keycloak_client_lookup_effective: >-
          {{ keycloak_client_lookup_retry
             if (keycloak_client_lookup_unauthorized | bool)
             else keycloak_client_lookup }}

    - name: Build client UUID map
      set_fact:
        keycloak_client_uuid_map: >-
          {{ keycloak_client_uuid_map | default({})
             | combine({
                item.item.client_id: ((item.json | default([]) | first).id | default(''))
             }) }}
      loop: "{{ keycloak_client_lookup_effective.results | default([]) }}"

    - name: Fetch client secrets
      uri:
        url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/clients/{{ keycloak_client_uuid_map[item.client_id] }}/client-secret"
        method: GET
        headers:
          Authorization: "Bearer {{ keycloak_bearer_token }}"
        status_code:
          - 200
          - 401
        timeout: 60
      loop: "{{ keycloak_oidc_clients }}"
      when: (keycloak_client_uuid_map[item.client_id] | default('') | trim) != ''
      register: keycloak_client_secrets_get

    - name: Detect unauthorized responses during client-secret GET
      set_fact:
        keycloak_client_secret_get_unauthorized: >-
          {{ (keycloak_client_secrets_get.results | default([]))
             | selectattr('status', 'equalto', 401)
             | list
             | length > 0 }}

    - name: Refresh token if any client-secret GET returned 401
      include_tasks: refresh-token.yml
      when: keycloak_client_secret_get_unauthorized | bool

    - name: Retry fetching client secrets after token refresh
      uri:
        url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/clients/{{ keycloak_client_uuid_map[item.client_id] }}/client-secret"
        method: GET
        headers:
          Authorization: "Bearer {{ keycloak_bearer_token }}"
        status_code: 200
        timeout: 60
      loop: "{{ keycloak_oidc_clients }}"
      when:
        - keycloak_client_secret_get_unauthorized | bool
        - (keycloak_client_uuid_map[item.client_id] | default('') | trim) != ''
      register: keycloak_client_secrets_get_retry

    - name: Select effective GET results
      set_fact:
        keycloak_client_secrets_get_effective: >-
          {{ keycloak_client_secrets_get_retry
             if (keycloak_client_secret_get_unauthorized | bool)
             else keycloak_client_secrets_get }}

    - name: Build client-secret map from GET results
      set_fact:
        keycloak_client_secret_get_map: >-
          {{ keycloak_client_secret_get_map | default({})
             | combine({
                item.item.client_id: (((item.json | default({})).value | default('')) | trim)
             }) }}
      loop: "{{ keycloak_client_secrets_get_effective.results | default([]) }}"
      when:
        - item is defined
        - (item.skipped | default(false)) | bool == false
        - item.item is defined
        - item.item.client_id is defined

    - name: Build list of OIDC clients needing secret regeneration
      set_fact:
        keycloak_oidc_clients_needing_regen: "{{ (keycloak_oidc_clients_needing_regen | default([])) + [item] }}"
      loop: "{{ keycloak_oidc_clients }}"
      when:
        - (keycloak_client_uuid_map[item.client_id] | default('') | trim) != ''
        - keycloak_force_regenerate_client_secrets | default(false) | bool
          or ((keycloak_client_secret_get_map[item.client_id] | default('') | trim) == '')

    - name: Regenerate client secrets when GET value is missing (or forced)
      uri:
        url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/clients/{{ keycloak_client_uuid_map[item.client_id] }}/client-secret"
        method: POST
        headers:
          Authorization: "Bearer {{ keycloak_bearer_token }}"
        status_code:
          - 200
          - 401
        timeout: 60
      loop: "{{ keycloak_oidc_clients_needing_regen | default([]) }}"
      register: keycloak_client_secrets_post

    - name: Detect unauthorized responses during client-secret POST
      set_fact:
        keycloak_client_secret_post_unauthorized: >-
          {{ (keycloak_client_secrets_post.results | default([]))
             | selectattr('status', 'equalto', 401)
             | list
             | length > 0 }}
      when: keycloak_client_secrets_post is defined

    - name: Refresh token if any client-secret POST returned 401
      include_tasks: refresh-token.yml
      when:
        - keycloak_client_secrets_post is defined
        - keycloak_client_secret_post_unauthorized | default(false) | bool

    - name: Retry regenerating missing client secrets after token refresh
      uri:
        url: "{{ keycloak_admin_base_url }}/admin/realms/{{ keycloak_realm }}/clients/{{ keycloak_client_uuid_map[item.client_id] }}/client-secret"
        method: POST
        headers:
          Authorization: "Bearer {{ keycloak_bearer_token }}"
        status_code: 200
        timeout: 60
      loop: "{{ keycloak_oidc_clients_needing_regen | default([]) }}"
      when:
        - keycloak_client_secrets_post is defined
        - keycloak_client_secret_post_unauthorized | default(false) | bool
      register: keycloak_client_secrets_post_retry

    - name: Build client-secret map from POST results (regenerated secrets)
      set_fact:
        keycloak_client_secret_regen_map: >-
          {{ keycloak_client_secret_regen_map | default({})
             | combine({
                item.item.client_id: (((item.json | default({})).value | default('')) | trim)
             }) }}
      loop: "{{ (keycloak_client_secrets_post.results | default([])) }}"
      when:
        - keycloak_client_secrets_post is defined
        - item is defined
        - (item.skipped | default(false)) | bool == false
        - item.item is defined
        - item.item.client_id is defined

    - name: Overlay regenerated secrets with retry results (if any)
      set_fact:
        keycloak_client_secret_regen_map: >-
          {{ keycloak_client_secret_regen_map | default({})
             | combine({
                item.item.client_id: (((item.json | default({})).value | default('')) | trim)
             }) }}
      loop: "{{ (keycloak_client_secrets_post_retry.results | default([])) }}"
      when:
        - keycloak_client_secrets_post_retry is defined
        - item is defined
        - (item.skipped | default(false)) | bool == false
        - item.item is defined
        - item.item.client_id is defined

    - name: Build final client-secret map (GET preferred unless forced/missing)
      set_fact:
        keycloak_client_secret_final_map: >-
          {{ keycloak_client_secret_final_map | default({})
             | combine({
                item.client_id: (
                  (keycloak_client_secret_regen_map[item.client_id] | default('') | trim)
                  if (
                    (keycloak_force_regenerate_client_secrets | default(false) | bool)
                    or ((keycloak_client_secret_get_map[item.client_id] | default('') | trim) == '')
                  )
                  else (keycloak_client_secret_get_map[item.client_id] | default('') | trim)
                )
             }) }}
      loop: "{{ keycloak_oidc_clients }}"
      when: (keycloak_client_uuid_map[item.client_id] | default('') | trim) != ''

    - name: Apply Kubernetes secrets with OIDC client credentials
      shell: >-
        KUBECONFIG=/etc/kubernetes/admin.conf kubectl -n {{ namespace_monitoring }}
        create secret generic {{ item.k8s_secret_name }}
        --from-literal=client-id={{ item.client_id }}
        --from-literal=client-secret={{ keycloak_client_secret_final_map[item.client_id] }}
        --dry-run=client -o yaml | kubectl apply -f -
      loop: "{{ keycloak_oidc_clients }}"
      when:
        - (keycloak_client_uuid_map[item.client_id] | default('') | trim) != ''
        - (keycloak_client_secret_final_map[item.client_id] | default('') | trim) != ''
      become: true

    - name: Fail if any client secret value could not be obtained
      fail:
        msg: >-
          Failed to obtain Keycloak client secret for clientId={{ item.client_id }}.
          This usually indicates an auth/token issue or Keycloak did not return a secret value.
      loop: "{{ keycloak_oidc_clients }}"
      when:
        - (keycloak_client_uuid_map[item.client_id] | default('') | trim) != ''
        - (keycloak_client_secret_final_map[item.client_id] | default('') | trim) == ''

- name: Display automated SSO configuration result
  debug:
    msg: |
      ============================================================
      Keycloak SSO Configuration: AUTOMATED
      ============================================================
      Realm: {{ keycloak_realm }}
      Realm file: {{ keycloak_realm_json_path }}

      LDAP federation provider: freeipa
      Connection URL: {{ freeipa_ldap_connection_url }}
      Users DN: {{ freeipa_ldap_users_dn }}

      OIDC client secrets exported: {{ 'yes' if keycloak_export_oidc_client_secrets | default(true) | bool else 'no' }}
      Monitoring namespace: {{ namespace_monitoring }}

      Next: Configure your apps (Grafana/Prometheus) to use Keycloak realm '{{ keycloak_realm }}'.
      ============================================================
