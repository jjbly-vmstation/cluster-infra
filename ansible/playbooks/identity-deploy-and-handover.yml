---
# Playbook: identity-deploy-and-handover.yml
# Purpose: Deploy FreeIPA, Keycloak, (optional) SAML config and hand over
# the FreeIPA CA to cert-manager by creating a Secret and ClusterIssuer.
# Also create a root-owned backup of CA material under `/root/identity-backup`
# so cluster recovery is possible if the identity node fails.

- name: Deploy identity stack and hand over CA to cert-manager
  hosts: localhost
  connection: local
  gather_facts: false
  vars:
    # Paths or manifests to use when available. Adjust these to your repo layout.
    freeipa_manifest: "/opt/vmstation-org/cluster-infra/manifests/freeipa.yaml"
    keycloak_manifest: "/opt/vmstation-org/cluster-infra/manifests/keycloak.yaml"
    keycloak_helm_chart: "codecentric/keycloak"
    keycloak_values_file: "/opt/vmstation-org/cluster-infra/helm/keycloak-values.yaml"
    
    # Storage manifests for Keycloak PostgreSQL
    storage_class_manifest: "/opt/vmstation-org/cluster-infra/manifests/identity/storage-class-manual.yaml"
    keycloak_pv_manifest: "/opt/vmstation-org/cluster-infra/manifests/identity/keycloak-postgresql-pv.yaml"

    # CA sources (from your pre-generate step in cluster-setup)
    ca_cert_src: "/opt/vmstation-org/cluster-setup/scripts/certs/ca.cert.pem"
    ca_key_src:  "/opt/vmstation-org/cluster-setup/scripts/certs/ca.key.pem"

    # Kubernetes targets
    namespace_cert_manager: cert-manager
    namespace_identity: identity
    namespace_platform: platform
    secret_name: freeipa-ca
    clusterissuer_name: freeipa-ca-issuer
    template_dest: "/tmp/clusterissuer-freeipa.yml"

    # Backup location on the controller (root-owned)
    backup_dir: /root/identity-backup
    
    # Identity data storage location (for PostgreSQL persistent data)
    identity_data_dir: /srv/identity_data

  tasks:
    - name: Ensure required binaries are present (kubectl, helm)
      shell: which {{ item }}
      register: which_out
      failed_when: which_out.rc != 0
      changed_when: false
      loop:
        - kubectl
        - helm

    

    - name: Ensure identity-related namespaces exist
      shell: >-
        kubectl create namespace {{ item }} --dry-run=client -o yaml | kubectl apply -f -
      loop:
        - "{{ namespace_cert_manager }}"
        - "{{ namespace_identity }}"
        - "{{ namespace_platform }}"
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      changed_when: false

    - name: Create identity data directories for PostgreSQL storage
      file:
        path: "{{ identity_data_dir }}/postgresql"
        state: directory
        mode: '0755'
        owner: root
        group: root
      become: true

    - name: Ensure nodes are schedulable (uncordon all nodes)
      shell: |
        kubectl --kubeconfig=/etc/kubernetes/admin.conf get nodes --no-headers | awk '{print $1}' | xargs -n1 kubectl --kubeconfig=/etc/kubernetes/admin.conf uncordon
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      register: uncordon_result
      failed_when: false
      changed_when: false

    - name: Deploy StorageClass for Keycloak PostgreSQL
      shell: kubectl apply -f {{ storage_class_manifest }}
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      register: storage_class_apply
      when: storage_class_manifest is defined

    - name: Deploy PersistentVolume for Keycloak PostgreSQL
      shell: kubectl apply -f {{ keycloak_pv_manifest }}
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      register: keycloak_pv_apply
      when: keycloak_pv_manifest is defined

    - name: Deploy FreeIPA from manifest if present
      stat:
        path: "{{ freeipa_manifest }}"
      register: freeipa_manifest_stat

    - name: Apply FreeIPA manifest
      shell: kubectl apply -f {{ freeipa_manifest }}
      when: freeipa_manifest_stat.stat.exists
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      register: freeipa_apply

    - name: Inform about missing FreeIPA manifest
      debug:
        msg: "FreeIPA manifest {{ freeipa_manifest }} not found. Provide a manifest or deploy FreeIPA by other means."
      when: not freeipa_manifest_stat.stat.exists

    - name: Deploy Keycloak (manifest if present)
      stat:
        path: "{{ keycloak_manifest }}"
      register: keycloak_manifest_stat

    - name: Apply Keycloak manifest
      shell: kubectl apply -f {{ keycloak_manifest }}
      when: keycloak_manifest_stat.stat.exists
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      register: keycloak_apply

    - name: Check if Keycloak values file has placeholder passwords
      shell: |
        if grep -q "CHANGEME" {{ keycloak_values_file }} 2>/dev/null; then
          echo "WARNING: Keycloak values file contains CHANGEME placeholders. Replace them before production use."
          exit 0
        fi
      when: keycloak_values_file is defined
      register: password_check
      changed_when: false
      failed_when: false

    - name: Display password placeholder warning
      debug:
        msg: "{{ password_check.stdout }}"
      when: password_check is defined and password_check.stdout != ""

    - name: Install Keycloak via Helm if manifest missing but values file exists
      # Force a known-good Postgres image for environments that cannot pull the
      # Bitnami tag (registry issues, removed tag, or proxy returning HTML errors).
      shell: >-
        helm repo add codecentric https://codecentric.github.io/helm-charts >/dev/null 2>&1 || true;
        helm repo update >/dev/null 2>&1;
        helm upgrade --install keycloak {{ keycloak_helm_chart }} -n {{ namespace_identity }} -f {{ keycloak_values_file }} --create-namespace \
          --set postgresql.image.registry=docker.io \
          --set postgresql.image.repository=postgres \
          --set postgresql.image.tag=11 \
          --set postgresql.image.pullPolicy=IfNotPresent
      when: not keycloak_manifest_stat.stat.exists and (keycloak_values_file is defined)
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      register: keycloak_helm_install

    - name: Check Keycloak PostgreSQL PVC status (non-fatal)
      shell: >-
        KUBECONFIG=/etc/kubernetes/admin.conf kubectl get pvc data-keycloak-postgresql-0 -n {{ namespace_identity }} -o jsonpath='{.status.phase}' || true
      register: keycloak_postgres_pvc_phase
      changed_when: false

    - name: Find Available PVs labeled for Keycloak Postgres
      shell: >-
        KUBECONFIG=/etc/kubernetes/admin.conf kubectl get pv -l app=keycloak,component=postgresql -o jsonpath='{range .items[?(@.status.phase=="Available")]}{.metadata.name}{"\n"}{end}' || true
      register: keycloak_postgres_available_pvs
      changed_when: false

    - name: Bind an Available PV to Keycloak PVC when PVC is Pending
      shell: >-
        KUBECONFIG=/etc/kubernetes/admin.conf kubectl patch pv {{ item }} -p '{"spec":{"claimRef":{"namespace":"{{ namespace_identity }}","name":"data-keycloak-postgresql-0"}}}' --type=merge
      loop: "{{ keycloak_postgres_available_pvs.stdout_lines }}"
      when: keycloak_postgres_pvc_phase.stdout == 'Pending' and keycloak_postgres_available_pvs.stdout != ''
      register: keycloak_pv_bind
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf

    - name: Verify Keycloak PVC after binding attempt
      shell: >-
        KUBECONFIG=/etc/kubernetes/admin.conf kubectl get pvc data-keycloak-postgresql-0 -n {{ namespace_identity }} -o wide
      register: keycloak_postgres_pvc_verify
      changed_when: false

    - name: Warn if neither manifest nor values file available for Keycloak
      debug:
        msg: "Keycloak manifest not found and values file missing; please provide one to automate Keycloak install."
      when: not keycloak_manifest_stat.stat.exists and (keycloak_values_file is not defined or keycloak_values_file == '')

    - name: Wait for Keycloak PostgreSQL rollout (best-effort)
      shell: KUBECONFIG=/etc/kubernetes/admin.conf kubectl rollout status statefulset/keycloak-postgresql -n {{ namespace_identity }} --timeout=180s
      register: keycloak_pg_rollout
      changed_when: keycloak_pg_rollout.rc == 0
      failed_when: false

    - name: Attempt recovery for Postgres StatefulSet if rollout failed
      when: keycloak_pg_rollout.rc != 0
      block:
        - name: Scale down Postgres StatefulSet to 0
          shell: KUBECONFIG=/etc/kubernetes/admin.conf kubectl -n {{ namespace_identity }} scale sts keycloak-postgresql --replicas=0
          register: scale_down_pg
          failed_when: false

        - name: Delete any remaining Postgres pods to ensure fresh recreate
          shell: KUBECONFIG=/etc/kubernetes/admin.conf kubectl -n {{ namespace_identity }} delete pod -l app.kubernetes.io/name=postgresql --ignore-not-found
          register: delete_pg_pods
          failed_when: false

        - name: Scale up Postgres StatefulSet to 1
          shell: KUBECONFIG=/etc/kubernetes/admin.conf kubectl -n {{ namespace_identity }} scale sts keycloak-postgresql --replicas=1
          register: scale_up_pg
          failed_when: false

        - name: Wait for Postgres StatefulSet rollout after recovery
          shell: KUBECONFIG=/etc/kubernetes/admin.conf kubectl rollout status statefulset/keycloak-postgresql -n {{ namespace_identity }} --timeout=180s
          register: keycloak_pg_rollout_after
          failed_when: false

    - name: Wait for Keycloak rollout (best-effort)
      shell: KUBECONFIG=/etc/kubernetes/admin.conf kubectl rollout status statefulset/keycloak -n {{ namespace_identity }} --timeout=180s
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      ignore_errors: true

    - name: Ensure cert-manager CRDs are installed (idempotent)
      shell: >-
        kubectl apply -f https://github.com/jetstack/cert-manager/releases/latest/download/cert-manager.crds.yaml
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      changed_when: false

    - name: Add cert-manager Helm repo
      shell: |
        helm repo add jetstack https://charts.jetstack.io || true
        helm repo update
      changed_when: false

    - name: Install/upgrade cert-manager Helm chart (installCRDs=false)
      shell: >-
        KUBECONFIG=/etc/kubernetes/admin.conf helm upgrade --install cert-manager jetstack/cert-manager --namespace {{ namespace_cert_manager }} --create-namespace --set installCRDs=false
      register: certmgr_helm

    - name: Wait for cert-manager deployments to be ready (with diagnostics on failure)
      block:
        - name: Wait for cert-manager controller rollout
          shell: >-
            KUBECONFIG=/etc/kubernetes/admin.conf kubectl rollout status deployment/cert-manager -n {{ namespace_cert_manager }} --timeout=180s
          register: certmgr_rollout_controller
          failed_when: certmgr_rollout_controller.rc != 0
          environment:
            KUBECONFIG: /etc/kubernetes/admin.conf

        - name: Wait for cert-manager webhook rollout
          shell: >-
            KUBECONFIG=/etc/kubernetes/admin.conf kubectl rollout status deployment/cert-manager-webhook -n {{ namespace_cert_manager }} --timeout=180s
          register: certmgr_rollout_webhook
          failed_when: certmgr_rollout_webhook.rc != 0
          environment:
            KUBECONFIG: /etc/kubernetes/admin.conf

        - name: Wait for cert-manager cainjector rollout
          shell: >-
            KUBECONFIG=/etc/kubernetes/admin.conf kubectl rollout status deployment/cert-manager-cainjector -n {{ namespace_cert_manager }} --timeout=180s
          register: certmgr_rollout_cainjector
          failed_when: certmgr_rollout_cainjector.rc != 0
          environment:
            KUBECONFIG: /etc/kubernetes/admin.conf

      rescue:
        - name: Get UTC timestamp for diagnostics filename
          shell: date -u +%Y%m%dT%H%M%SZ
          register: diag_ts
          changed_when: false

        - name: Collect cert-manager pod list and status
          shell: KUBECONFIG=/etc/kubernetes/admin.conf kubectl -n {{ namespace_cert_manager }} get pods -o wide
          register: certmgr_pods
          changed_when: false

        - name: Describe cert-manager namespace pods
          shell: |
            for p in $(kubectl -n {{ namespace_cert_manager }} get pods -o name); do
              echo "=== $p ===";
              kubectl -n {{ namespace_cert_manager }} describe $p || true;
            done
          register: certmgr_describe
          changed_when: false
          environment:
            KUBECONFIG: /etc/kubernetes/admin.conf

        - name: Collect cert-manager webhook logs (best-effort)
          shell: |
            set -e; for p in $(kubectl -n {{ namespace_cert_manager }} get pods -l app.kubernetes.io/component=webhook -o name 2>/dev/null || true); do
              echo "=== logs $p ===";
              kubectl -n {{ namespace_cert_manager }} logs $p --all-containers || true;
            done
          register: certmgr_logs
          changed_when: false
          environment:
            KUBECONFIG: /etc/kubernetes/admin.conf

        - name: Collect events in cert-manager namespace
          shell: KUBECONFIG=/etc/kubernetes/admin.conf kubectl -n {{ namespace_cert_manager }} get events --sort-by=.metadata.creationTimestamp
          register: certmgr_events
          changed_when: false

        - name: Save cert-manager diagnostics to root backup dir
          copy:
            dest: "{{ backup_dir }}/cert-manager-diagnostics-{{ diag_ts.stdout }}.log"
            content: |
              ===== PODS =====
              {{ certmgr_pods.stdout | default('') }}
              ===== DESCRIBE =====
              {{ certmgr_describe.stdout | default('') }}
              ===== LOGS =====
              {{ certmgr_logs.stdout | default('') }}
              ===== EVENTS =====
              {{ certmgr_events.stdout | default('') }}
            owner: root
            group: root
            mode: '0600'
          become: true

        - name: Fail with diagnostics notice for operator
          fail:
            msg: "cert-manager deployments did not become ready within timeout. Diagnostics saved to {{ backup_dir }}/cert-manager-diagnostics-{{ diag_ts.stdout }}.log"

    - name: Ensure ClusterIssuer CRD exists before creating ClusterIssuer
      shell: >-
        KUBECONFIG=/etc/kubernetes/admin.conf kubectl get crd clusterissuers.cert-manager.io
      register: crd_check
      failed_when: crd_check.rc != 0
      changed_when: false

    - name: Ensure CA cert file exists
      stat:
        path: "{{ ca_cert_src }}"
      register: ca_cert_stat

    - name: Ensure backup directory exists (root-owned)
      file:
        path: "{{ backup_dir }}"
        state: directory
        owner: root
        group: root
        mode: '0700'

    - name: Backup CA material to root backup (cert and key if present)
      shell: >-
        set -e;
        cp -f {{ ca_cert_src }} {{ backup_dir }}/ca.cert.pem || true;
        if [ -f "{{ ca_key_src }}" ]; then cp -f {{ ca_key_src }} {{ backup_dir }}/ca.key.pem; fi;
        tar -C {{ backup_dir }} -czf {{ backup_dir }}/identity-ca-backup.tar.gz --remove-files $(ls {{ backup_dir }} | grep -E 'ca.(cert|key).pem' || true) >/dev/null 2>&1 || true;
      when: ca_cert_stat.stat.exists
      register: backup_run
      changed_when: backup_run.rc == 0

    - name: Create or update Kubernetes Secret with CA
      shell: >-
        kubectl create secret generic {{ secret_name }} --namespace {{ namespace_cert_manager }} --from-file=ca.crt={{ ca_cert_src }} --dry-run=client -o yaml | kubectl apply -f -
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      register: secret_apply

    - name: Render ClusterIssuer template
      template:
        src: "../templates/clusterissuer-freeipa.yml.j2"
        dest: "{{ template_dest }}"

    - name: Apply ClusterIssuer to cluster
      shell: kubectl apply -f {{ template_dest }}
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      register: issuer_apply

    - name: Show results
      debug:
        msg: |
          StorageClass applied: {{ storage_class_apply.stdout | default('not applied') }}
          Keycloak PV applied: {{ keycloak_pv_apply.stdout | default('not applied') }}
          FreeIPA applied: {{ freeipa_apply.stdout | default('not applied') }}
          Keycloak applied: {{ keycloak_apply.stdout | default(keycloak_helm_install.stdout | default('not applied')) }}
          Secret apply stdout: {{ secret_apply.stdout }}
          ClusterIssuer apply stdout: {{ issuer_apply.stdout }}

    - name: Final guidance
      debug:
        msg: |
          Identity stack deployment attempted. Verify FreeIPA and Keycloak pods are Running and
          that cert-manager is installed and healthy. The CA backup (if available) was stored at {{ backup_dir }}/identity-ca-backup.tar.gz
          
          Storage configuration:
          - StorageClass 'manual' has been created for manual PV provisioning
          - PersistentVolume 'keycloak-postgresql-pv' (10Gi) created at {{ identity_data_dir }}/postgresql
          - Keycloak PostgreSQL PVC should now bind successfully
